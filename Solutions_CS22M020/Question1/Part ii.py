# -*- coding: utf-8 -*-
"""EMPart2Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16susO4sA_CgOt2XzghNceRB74MtcJYt5
"""

#importing all the libraries to be used 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
uploaded=files.upload()

#load the data file here 
df=pd.read_csv('A2Q1.csv',header=None)
df=df.to_numpy()
n=df.shape[0]
m=df.shape[1]

#pick any k random data point and call them as cluster
import random
def randomCentroids(k):
  centroids=[]
  for i in range(k):
    index=random.randint(0,n-1)
    centroids.append(df[index,:])
  return centroids

def calculateDistance(x,y):
  #these x and y are supposed to be m dimensional vectors
  dist=0;
  for i in range(len(x)):
    diff=x[i]-y[i]
    diff=diff*diff
    dist=dist+diff
  return dist

#we need to assign for the first time data point to each cluster
def assign(centroids,k):
  z=[]
  for i in range(n):
    x=df[i,:]
    temp_dist=[]
    for j in range(k):
      y=centroids[j]
      dist=calculateDistance(x,y)
      temp_dist.append(dist)
    index=np.argmin(temp_dist)
    z.append(index)
  return z

def calculateMean(z,centroids,k):
  #we have to calulate mean for all 4 clusters i.e meu
  meu=[]
  for i in range(k):
    sum=[]
    num=0;
    for j in range(n):
      if z[j]==i:
        num=num+1
        sum.append(df[j,:])
    meu.append(np.mean(sum,axis=0))
  return meu
#this will return all the meu

#i have all the basic functionality now
def reassign(z,meu,k):
  #meu contains all the means of the clusters
  #check all points if they want to switch their means
  flag=False
  znew=[]
  for i in range(n):
    znew.append(z[i])
  for i in range(n):
    #for every point
    ownDist=calculateDistance(df[i,:],meu[z[i]])
    ownClus=z[i]
    for j in range(k):
      nextDist=calculateDistance(df[i,:],meu[j])
      if nextDist<ownDist:
        ownDist=nextDist
        ownClus=j
        flag=True
    znew[i]=ownClus
  return (flag,znew)

def computeErrors(meu,z):
  #we know the mean matrix and the point assignment, compute the error
  error=0
  for i in range(n):
    error=error+calculateDistance(df[i,:],meu[z[i]])
  return error

def llyod(k,num):
  err=[]
  clusters=randomCentroids(k)
  z=assign(clusters,k)
  meu=calculateMean(z,clusters,k)
  e=0
  e=e+computeErrors(meu,z)
  err.append(e)
  r,znew=reassign(z,meu,k)
  z=np.copy(znew)
  #print(z)
  meu=calculateMean(z,clusters,k)
  e=0
  e=e+computeErrors(meu,z)
  err.append(e)
  count=0
  while r:
    r,znew=reassign(z,meu,k)
    z=np.copy(znew)
    meu=calculateMean(z,clusters,k)
    e=0
    e=e+computeErrors(meu,z)
    err.append(e)
    count=count+1
  return (meu,z)

def countPoints(z):
  freq=np.zeros(4)
  for i in range(len(z)):
    freq[z[i]]=freq[z[i]]+1
  return freq

def countO():
  o=np.zeros(400)
  for i in range(400):
    o[i]=np.sum(df[i,:])
  return o

def segregate(X,meu,z):
  x0=[]
  x1=[]
  x2=[]
  x3=[]
  for i in range(400):
    if z[i]==0:
      x0.append(X[i]-meu[0])
    elif z[i]==1:
      x1.append(X[i]-meu[1])
    elif z[i]==2:
      x2.append(X[i]-meu[2])
    elif z[i]==3:
      x3.append(X[i]-meu[3])
    #x0=np.array(x0)
    #x1=np.array(x1)
    #x2=np.array(x2)
    #x3=np.array(x3)
  return (x0,x1,x2,x3)

def calculatePI(l):
  pi=np.sum(l,axis=0)/400
  return pi

def initialSigma(x0,x1,x2,x3):
  sigma=[]
  sigma.append(((1/x0.shape[0])*np.matmul(x0.T,x0)))
  sigma.append(((1/x1.shape[0])*np.matmul(x1.T,x1)))
  sigma.append(((1/x2.shape[0])*np.matmul(x2.T,x2)))
  sigma.append(((1/x3.shape[0])*np.matmul(x3.T,x3)))
  sigma=np.array(sigma)
  #sigma will be 4*50*50 array
  return sigma

def pseudo_determinant(sigma):
    ev,_=np.linalg.eig(sigma)
    pd=1
    for i in range(len(ev)):
        if(ev[i]>1e-5):
            pd*=ev[i]
    return pd

import math
def GD(sigma,X):
  det=pseudo_determinant(sigma)
  piterm=np.power(2*math.pi,50)
  deno=np.power(det*piterm,1/2)
  inv=np.linalg.pinv(sigma)
  XT=np.array(X).T
  num=np.matmul(X,inv)
  num=np.matmul(num,XT)
  num=math.exp(-0.5*num)
  num=num/deno
  return num

def calculateLambda(X,pi,sigma,meu):
  l=np.zeros((400,4))
  for i in range(400):
    deno=0
    for j in range(4):
      deno=deno+GD(sigma[j],X[i]-meu[j])*pi[j]
    for k in range(4):
      num=GD(sigma[k],X[i]-meu[k])*pi[k]
      l[i][k]=num/deno
  return l

def calculateMeu(l,X):
  meu=[]
  for k in range(4):
    deno=0
    num=0
    for i in range(400):
      deno=deno+l[i][k]
      num=num+l[i][k]*X[i]
    meu.append(num/deno)
  return meu

def calculateSigma(lamb,X,meu):
  sigma_new=[]
  for j in range(4):
    s1=[[0]*50]*50
    s2=0
    for i in range(400):
      c=X[i,:]
      c=np.array(c-meu[j])
      cT=np.zeros((1,50))
      for l in range(50):
        cT[0][l]=c[l]
      s1=np.add(s1,((lamb[i][j].real)*(np.matmul(cT,c))))
      s2+=lamb[i][j].real
    sigma_new.append(s1/s2)
  return np.array(sigma_new)

def logLike(pi,meu,sigma,X):
  ans=0
  for i in range(400):
    ans_sub=0
    for k in range(4):
      ans_sub=ans_sub+GD(sigma[k],X[i]-meu[k])*pi[k]
    ans=ans+np.log(ans_sub)
  return ans

def initializeEM():
  meu,z=llyod(4,1)
  meu=np.array(meu)
  #meu=meu.T
  #meu is a 4*50 array 
  x0,x1,x2,x3=segregate(df,meu,z)
  x0=np.array(x0)
  x1=np.array(x1)
  x2=np.array(x2)
  x3=np.array(x3)
  print(x0.shape)
  sigma=initialSigma(x0,x1,x2,x3)
  pi=countPoints(z)/400
  return (meu,sigma,pi)

def runEM(meu,sigma,pi):
  logLikeList=[]
  meu_old=meu
  sigma_old=sigma
  pi_old=pi
  count=0
  while True:
    print("Iteration ", count)
    count=count+1
    l_new=calculateLambda(df,pi_old,sigma_old,meu_old)
    pi_new=calculatePI(l_new)
    meu_new=calculateMeu(l_new,df)
    meu_new=np.array(meu_new)
    sigma_new=calculateSigma(l_new,df,meu_new)
    ll_new=logLike(pi_new,meu_new,sigma_new,df)
    logLikeList.append(ll_new)
    p=np.sum(np.abs(pi_new-pi_old))
    q=[]
    for i in range(4):
      q.append(meu_new[i]-meu_old[i])
    q=np.array(q)
    q.flatten()
    r=np.linalg.norm(q)
    z=0
    for i in range(4):
      t=(sigma_new[i]-sigma_old[i])
    t=np.array(t)
    t.flatten()
    z+=np.linalg.norm(t)
    if(p<=1e-10 and r<=1e-10 and z<=1e-10):
      break
    meu_old=meu_new
    pi_old=pi_new
    sigma_old=sigma_new
  return logLikeList

def control():
  meu,sigma,pi=initializeEM()
  return runEM(meu,sigma,pi)

ans=[]

for i in range(100):
  ans.append(control())
print(ans)

print(len(ans))

max=0
for i in range(19):
    if(len(ans[i])>max):
        max=len(ans[i])
for i in range(19):
    ele=ans[i][len(ans[i])-1]
    for j in range(max-len(ans[i])):
        ans[i].append(ele)
final_likelihood=[]
for j in range(max):
    sum=0
    for i in range(19):
        sum+=ans[i][j]
    final_likelihood.append(sum/19)
iteration=[]
for i in range(max):
    iteration.append(i)

#plotting error w.r.t. iterations 
f2=plt.figure(1)
plt.xlabel('X-axis --Iterations',color='black')
plt.ylabel('Y-axis --Maximum Likelihood',color='black')
plt.title('Maximum Likelihood w.r.t. Iterations',color='black')
plt.plot(iteration,final_likelihood) 
plt.grid()
plt.show()

